diff --git a/Makefile b/Makefile
index 74e454f..51593b0 100644
--- a/Makefile
+++ b/Makefile
@@ -194,7 +194,8 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
-
+	$U/_trace\
+	$U/_sysinfotest\
 
 
 
@@ -203,6 +204,7 @@ UPROGS += \
 	$U/_attack\
 	$U/_attacktest\
 	$U/_secret
+	
 endif
 
 ifeq ($(LAB),lock)
@@ -374,4 +376,4 @@ submit-check:
 zipball: clean submit-check
 	git archive --verbose --format zip --output lab.zip HEAD
 
-.PHONY: zipball clean grade submit-check
+.PHONY: zipball clean grade submit-check
\ No newline at end of file
diff --git a/kernel/defs.h b/kernel/defs.h
index d1b6bb9..c693228 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -63,6 +63,8 @@ void            ramdiskrw(struct buf*);
 void*           kalloc(void);
 void            kfree(void *);
 void            kinit(void);
+uint64 getfreemem(void);
+
 
 // log.c
 void            initlog(int, struct superblock*);
@@ -106,6 +108,7 @@ void            yield(void);
 int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);
+uint64 getnproc(void);
 
 // swtch.S
 void            swtch(struct context*, struct context*);
@@ -141,6 +144,7 @@ int             fetchstr(uint64, char*, int);
 int             fetchaddr(uint64, uint64*);
 void            syscall();
 
+
 // trap.c
 extern uint     ticks;
 void            trapinit(void);
@@ -186,4 +190,4 @@ void            virtio_disk_rw(struct buf *, int);
 void            virtio_disk_intr(void);
 
 // number of elements in fixed-size array
-#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
\ No newline at end of file
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index 5247b91..3c77514 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -91,3 +91,15 @@ kalloc(void)
   return (void*)r;
 }
 
+uint64 getfreemem(void) {
+    struct run *r;
+    uint64 free_mem = 0;
+
+    acquire(&kmem.lock);
+    for (r = kmem.freelist; r; r = r->next) {
+        free_mem += PGSIZE;
+    }
+    release(&kmem.lock);
+
+    return free_mem;
+}
\ No newline at end of file
diff --git a/kernel/proc.c b/kernel/proc.c
index 130d9ce..8fbecdf 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -322,6 +322,8 @@ fork(void)
   np->state = RUNNABLE;
   release(&np->lock);
 
+  np->trace_mask = p->trace_mask;
+  
   return pid;
 }
 
@@ -693,3 +695,15 @@ procdump(void)
     printf("\n");
   }
 }
+
+uint64 getnproc(void) {
+    struct proc *p;
+    uint64 count = 0;
+
+    for (p = proc; p < &proc[NPROC]; p++) {
+        if (p->state != UNUSED) {
+            count++;
+        }
+    }
+    return count;
+}
\ No newline at end of file
diff --git a/kernel/proc.h b/kernel/proc.h
index d021857..a0cf91b 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -104,4 +104,6 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
-};
+
+  int trace_mask;  // Mask bật/tắt trace syscall
+};
\ No newline at end of file
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..6065a4a 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -101,6 +101,8 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
+extern uint64 sys_trace(void);
+extern uint64 sys_sysinfo(void);
 
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
@@ -126,8 +128,54 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_trace]   sys_trace,
+[SYS_sysinfo] sys_sysinfo,
 };
 
+char *syscall_names[] = {
+    [SYS_fork]    = "fork",
+    [SYS_exit]    = "exit",
+    [SYS_wait]    = "wait",
+    [SYS_pipe]    = "pipe",
+    [SYS_read]    = "read",
+    [SYS_kill]    = "kill",
+    [SYS_exec]    = "exec",
+    [SYS_fstat]   = "fstat",
+    [SYS_chdir]   = "chdir",
+    [SYS_dup]     = "dup",
+    [SYS_getpid]  = "getpid",
+    [SYS_sbrk]    = "sbrk",
+    [SYS_sleep]   = "sleep",
+    [SYS_uptime]  = "uptime",
+    [SYS_open]    = "open",
+    [SYS_write]   = "write",
+    [SYS_mknod]   = "mknod",
+    [SYS_unlink]  = "unlink",
+    [SYS_link]    = "link",
+    [SYS_mkdir]   = "mkdir",
+    [SYS_close]   = "close",
+    [SYS_trace]   = "trace",
+    [SYS_sysinfo] = "sysinfo",
+};
+
+// Hàm ghi log trace syscall
+void log_syscall(int num) {
+    struct proc *p = myproc();
+    
+    // Kiểm tra xem syscall có cần được trace không
+    if (p->trace_mask & (1 << num)) {
+        // Lấy tên syscall từ mảng syscall_names
+        char *syscall_name = syscall_names[num];
+
+        // Lấy giá trị trả về của syscall từ trapframe
+        int retval = p->trapframe->a0;
+
+        // In thông tin syscall ra màn hình
+        printf("%d: syscall %s -> %d\n", p->pid, syscall_name, retval);
+    }
+}
+
+
 void
 syscall(void)
 {
@@ -135,13 +183,17 @@ syscall(void)
   struct proc *p = myproc();
 
   num = p->trapframe->a7;
+  
+  // Kiểm tra nếu num hợp lệ và tồn tại trong mảng syscalls
   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
-    // Use num to lookup the system call function for num, call it,
-    // and store its return value in p->trapframe->a0
+    // Gọi hàm syscall và lưu kết quả vào trapframe
     p->trapframe->a0 = syscalls[num]();
+
+    // Trước khi gọi syscall, ghi lại thông tin nếu cần thiết
+    log_syscall(num);
   } else {
     printf("%d %s: unknown sys call %d\n",
             p->pid, p->name, num);
     p->trapframe->a0 = -1;
   }
-}
+}
\ No newline at end of file
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..e153363 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,5 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_trace  22
+#define SYS_sysinfo 23
\ No newline at end of file
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 3b4d5bd..c1a1eac 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -5,7 +5,7 @@
 #include "memlayout.h"
 #include "spinlock.h"
 #include "proc.h"
-
+#include "sysinfo.h"
 uint64
 sys_exit(void)
 {
@@ -91,3 +91,33 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+uint64 sys_sysinfo(void) {
+    struct sysinfo info;
+    uint64 addr;
+
+    // Get the user-space pointer to the sysinfo struct
+    argaddr(0, &addr);
+
+    // Fill the sysinfo struct
+    info.freemem = getfreemem();
+    info.nproc = getnproc();
+
+    // Copy the struct back to user space
+    if (copyout(myproc()->pagetable, addr, (char*)&info, sizeof(info)) < 0)
+        return -1;
+
+    return 0;
+}
+
+uint64 sys_trace(void) {
+    int mask;
+    // Lấy tham số từ user space
+    argint(0, &mask);
+    if (mask < 0)
+      return -1;
+    // Lưu giá trị mask vào struct proc của tiến trình hiện tại
+    struct proc *p = myproc();
+    p->trace_mask = mask;
+    return 0;
+}
\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index f16fe27..2e36935 100644
--- a/user/user.h
+++ b/user/user.h
@@ -1,5 +1,5 @@
 struct stat;
-
+struct sysinfo;
 // system calls
 int fork(void);
 int exit(int) __attribute__((noreturn));
@@ -22,6 +22,8 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int sysinfo(struct sysinfo*);
+int trace(int mask);
 
 // ulib.c
 int stat(const char*, struct stat*);
@@ -40,4 +42,4 @@ void *memcpy(void *, const void *, uint);
 
 // umalloc.c
 void* malloc(uint);
-void free(void*);
+void free(void*);
\ No newline at end of file
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..353a1f8 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,5 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("trace");
+entry("sysinfo");
\ No newline at end of file
